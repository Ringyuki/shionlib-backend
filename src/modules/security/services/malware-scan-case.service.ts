import { InjectQueue } from '@nestjs/bull'
import { Injectable, Logger } from '@nestjs/common'
import {
  MalwareScanCaseStatus,
  MalwareScanDecisionSource,
  Prisma,
  HashAlgorithm,
} from '@prisma/client'
import fs from 'node:fs/promises'
import { Queue } from 'bull'
import { PrismaService } from '../../../prisma.service'
import { ActivityService } from '../../activity/services/activity.service'
import {
  ActivityFileCheckStatus,
  ActivityFileStatus,
  ActivityType,
} from '../../activity/dto/create-activity.dto'
import { ShionConfigService } from '../../../common/config/services/config.service'
import { MessageService } from '../../message/services/message.service'
import { MessageTone, MessageType } from '../../message/dto/req/send-message.req.dto'
import { EmailService } from '../../email/services/email.service'
import { ShionlibUserRoles } from '../../../shared/enums/auth/user-role.enum'
import { UserStatus } from '../../user/interfaces/user.interface'
import { UserService } from '../../user/services/user.service'
import { ShionBizException } from '../../../common/exceptions/shion-business.exception'
import { ShionBizCode } from '../../../shared/enums/biz-code/shion-biz-code.enum'
import { ArchiveStatus } from '../enums/archive-status.enum'
import { LARGE_FILE_UPLOAD_QUEUE, S3_UPLOAD_JOB } from '../../upload/constants/upload.constants'
import { UploadQuotaService } from '../../upload/services/upload-quota.service'
import { RequestWithUser } from '../../../shared/interfaces/auth/request-with-user.interface'
import { GetMalwareScanCaseListReqDto } from '../dto/req/get-malware-scan-case-list.req.dto'
import {
  MalwareScanCaseDecision,
  ReviewMalwareScanCaseReqDto,
} from '../dto/req/review-malware-scan-case.req.dto'

@Injectable()
export class MalwareScanCaseService {
  private readonly logger = new Logger(MalwareScanCaseService.name)

  constructor(
    private readonly prisma: PrismaService,
    private readonly configService: ShionConfigService,
    private readonly activityService: ActivityService,
    private readonly messageService: MessageService,
    private readonly emailService: EmailService,
    private readonly userService: UserService,
    private readonly uploadQuotaService: UploadQuotaService,
    @InjectQueue(LARGE_FILE_UPLOAD_QUEUE) private readonly uploadQueue: Queue,
  ) {}

  async registerInfectedFile(input: {
    fileId: number
    filePath: string
    resourceId: number
    gameId: number
    uploaderId: number
    fileName: string
    fileSize: number
    fileHash: string
    hashAlgorithm: HashAlgorithm
    scanResult: unknown
  }) {
    const detectedViruses = this.extractDetectedViruses(input.scanResult)
    const scanLogPath = this.configService.get('file_scan.clamscan_scan_log_path')
    const scanLogExcerpt = await this.readScanLogExcerpt(input.filePath)
    const reviewDeadline = new Date(
      Date.now() +
        this.configService.get('file_scan.malware_review_timeout_hours') * 60 * 60 * 1000,
    )

    const scanCase = await this.prisma.$transaction(async tx => {
      await tx.gameDownloadResourceFile.update({
        where: { id: input.fileId },
        data: {
          file_check_status: ArchiveStatus.HARMFUL_PENDING_REVIEW,
          is_virus_false_positive: false,
        },
      })

      await this.activityService.create(
        {
          type: ActivityType.FILE_CHECK_HARMFUL,
          user_id: input.uploaderId,
          game_id: input.gameId,
          file_id: input.fileId,
          file_status: ActivityFileStatus.UPLOADED_TO_SERVER,
          file_check_status: ActivityFileCheckStatus.HARMFUL,
          file_size: input.fileSize,
          file_name: input.fileName,
        },
        tx,
      )

      const created = await tx.malwareScanCase.create({
        data: {
          file_id: input.fileId,
          resource_id: input.resourceId,
          game_id: input.gameId,
          uploader_id: input.uploaderId,
          status: MalwareScanCaseStatus.PENDING,
          review_deadline: reviewDeadline,
          detector: 'clamscan',
          detected_viruses: detectedViruses,
          scan_result: this.toSafeJson(input.scanResult),
          scan_log_path: scanLogPath,
          scan_log_excerpt: scanLogExcerpt,
          file_name: input.fileName,
          file_size: BigInt(input.fileSize),
          file_hash: input.fileHash,
          hash_algorithm: input.hashAlgorithm,
        },
        select: {
          id: true,
          review_deadline: true,
          file_name: true,
          detected_viruses: true,
          game_id: true,
        },
      })

      await this.messageService.send(
        {
          type: MessageType.SYSTEM,
          tone: MessageTone.WARNING,
          title: 'Messages.System.File.Upload.FileVirusReviewPendingTitle',
          content: 'Messages.System.File.Upload.FileVirusReviewPendingContent',
          receiver_id: input.uploaderId,
          game_id: input.gameId,
          meta: {
            malware_case_id: created.id,
            file_name: input.fileName,
            review_deadline: created.review_deadline.toISOString(),
            detected_viruses: detectedViruses.join(', '),
          },
        },
        tx,
      )

      return created
    })

    await this.notifyAdminsPendingCase({
      caseId: scanCase.id,
      gameId: input.gameId,
      fileName: scanCase.file_name,
      uploaderId: input.uploaderId,
      reviewDeadline: scanCase.review_deadline,
      detectedViruses: scanCase.detected_viruses,
    })
  }

  async getList(dto: GetMalwareScanCaseListReqDto) {
    const {
      page,
      pageSize,
      status,
      decision_source,
      file_id,
      resource_id,
      uploader_id,
      reviewer_id,
      sortBy = 'created',
      sortOrder = 'desc',
    } = dto

    const where: Prisma.MalwareScanCaseWhereInput = {
      ...(status ? { status } : {}),
      ...(decision_source ? { decision_source } : {}),
      ...(file_id ? { file_id } : {}),
      ...(resource_id ? { resource_id } : {}),
      ...(uploader_id ? { uploader_id } : {}),
      ...(reviewer_id ? { reviewed_by: reviewer_id } : {}),
    }

    const [items, total] = await Promise.all([
      this.prisma.malwareScanCase.findMany({
        where,
        orderBy: { [sortBy]: sortOrder },
        skip: (page - 1) * pageSize,
        take: pageSize,
        select: {
          id: true,
          status: true,
          decision_source: true,
          review_note: true,
          review_deadline: true,
          reviewed_at: true,
          detector: true,
          detected_viruses: true,
          file_name: true,
          file_size: true,
          file_hash: true,
          hash_algorithm: true,
          notify_uploader_on_allow: true,
          uploader_notified_at: true,
          created: true,
          updated: true,
          file: {
            select: {
              id: true,
              file_status: true,
              file_check_status: true,
              is_virus_false_positive: true,
            },
          },
          resource: {
            select: {
              id: true,
              game_id: true,
              game: {
                select: {
                  id: true,
                  title_jp: true,
                  title_zh: true,
                  title_en: true,
                },
              },
            },
          },
          uploader: {
            select: {
              id: true,
              name: true,
              avatar: true,
            },
          },
          reviewer: {
            select: {
              id: true,
              name: true,
              avatar: true,
            },
          },
        },
      }),
      this.prisma.malwareScanCase.count({ where }),
    ])

    return {
      items: items.map(item => ({
        ...item,
        file_size: Number(item.file_size),
      })),
      meta: {
        totalItems: total,
        itemCount: items.length,
        itemsPerPage: pageSize,
        totalPages: Math.ceil(total / pageSize),
        currentPage: page,
      },
    }
  }

  async getById(id: number) {
    const scanCase = await this.prisma.malwareScanCase.findUnique({
      where: { id },
      select: {
        id: true,
        status: true,
        decision_source: true,
        review_note: true,
        review_deadline: true,
        reviewed_at: true,
        detector: true,
        detected_viruses: true,
        scan_result: true,
        scan_log_path: true,
        scan_log_excerpt: true,
        file_name: true,
        file_size: true,
        file_hash: true,
        hash_algorithm: true,
        notify_uploader_on_allow: true,
        uploader_notified_at: true,
        created: true,
        updated: true,
        file: {
          select: {
            id: true,
            type: true,
            file_status: true,
            file_check_status: true,
            is_virus_false_positive: true,
            upload_session_id: true,
            creator_id: true,
          },
        },
        resource: {
          select: {
            id: true,
            game_id: true,
            note: true,
            game: {
              select: {
                id: true,
                title_jp: true,
                title_zh: true,
                title_en: true,
              },
            },
          },
        },
        uploader: {
          select: {
            id: true,
            name: true,
            avatar: true,
            role: true,
            status: true,
          },
        },
        reviewer: {
          select: {
            id: true,
            name: true,
            avatar: true,
          },
        },
      },
    })

    if (!scanCase) {
      throw new ShionBizException(
        ShionBizCode.GAME_DOWNLOAD_RESOURCE_MALWARE_CASE_NOT_FOUND,
        'shion-biz.GAME_DOWNLOAD_RESOURCE_MALWARE_CASE_NOT_FOUND',
      )
    }

    return {
      ...scanCase,
      file_size: Number(scanCase.file_size),
    }
  }

  async review(id: number, dto: ReviewMalwareScanCaseReqDto, actor: RequestWithUser['user']) {
    await this.reviewCase({
      id,
      dto,
      reviewedBy: actor.sub,
      decisionSource:
        dto.decision === MalwareScanCaseDecision.ALLOW
          ? MalwareScanDecisionSource.ADMIN_ALLOW
          : MalwareScanDecisionSource.ADMIN_DELETE,
    })

    return this.getById(id)
  }

  async processExpiredCases() {
    const now = new Date()
    const pendingCases = await this.prisma.malwareScanCase.findMany({
      where: {
        status: MalwareScanCaseStatus.PENDING,
        review_deadline: {
          lte: now,
        },
      },
      orderBy: {
        review_deadline: 'asc',
      },
      take: 20,
      select: {
        id: true,
      },
    })

    let processed = 0
    for (const scanCase of pendingCases) {
      try {
        await this.reviewCase({
          id: scanCase.id,
          dto: {
            decision: MalwareScanCaseDecision.DELETE,
            review_note: this.configService.get('file_scan.malware_auto_delete_review_note'),
            notify_uploader: true,
          },
          decisionSource: MalwareScanDecisionSource.TIMEOUT_AUTO_DELETE,
        })
        processed++
      } catch (error) {
        const err = error as Error
        this.logger.error(
          `failed to process expired malware case ${scanCase.id}: ${err.message}`,
          err.stack,
        )
      }
    }

    return processed
  }

  private async reviewCase(input: {
    id: number
    dto: ReviewMalwareScanCaseReqDto
    decisionSource: MalwareScanDecisionSource
    reviewedBy?: number
  }) {
    const notifyUploader = input.dto.notify_uploader !== false
    if (input.dto.decision === MalwareScanCaseDecision.ALLOW) {
      let queuedFileId: number | null = null

      await this.prisma.$transaction(async tx => {
        const scanCase = await tx.malwareScanCase.findUnique({
          where: { id: input.id },
          include: {
            file: true,
            resource: {
              select: {
                game_id: true,
              },
            },
          },
        })
        if (!scanCase) {
          throw new ShionBizException(
            ShionBizCode.GAME_DOWNLOAD_RESOURCE_MALWARE_CASE_NOT_FOUND,
            'shion-biz.GAME_DOWNLOAD_RESOURCE_MALWARE_CASE_NOT_FOUND',
          )
        }
        if (scanCase.status !== MalwareScanCaseStatus.PENDING) {
          throw new ShionBizException(
            ShionBizCode.GAME_DOWNLOAD_RESOURCE_MALWARE_CASE_ALREADY_PROCESSED,
            'shion-biz.GAME_DOWNLOAD_RESOURCE_MALWARE_CASE_ALREADY_PROCESSED',
          )
        }

        if (scanCase.file) {
          await tx.gameDownloadResourceFile.update({
            where: { id: scanCase.file.id },
            data: {
              file_check_status: ArchiveStatus.OK,
              is_virus_false_positive: true,
            },
          })
          queuedFileId = scanCase.file.id

          await this.activityService.create(
            {
              type: ActivityType.FILE_CHECK_OK,
              user_id: scanCase.uploader_id,
              game_id: scanCase.game_id || scanCase.resource?.game_id || undefined,
              file_id: scanCase.file.id,
              file_status: ActivityFileStatus.UPLOADED_TO_SERVER,
              file_check_status: ActivityFileCheckStatus.OK,
              file_size: Number(scanCase.file.file_size),
              file_name: scanCase.file.file_name,
            },
            tx,
          )
        }

        const now = new Date()
        await tx.malwareScanCase.update({
          where: { id: scanCase.id },
          data: {
            status: MalwareScanCaseStatus.RELEASED_FALSE_POSITIVE,
            decision_source: input.decisionSource,
            reviewed_by: input.reviewedBy,
            reviewed_at: now,
            review_note: input.dto.review_note,
            notify_uploader_on_allow: notifyUploader,
            uploader_notified_at: notifyUploader ? now : null,
          },
        })

        if (notifyUploader) {
          await this.messageService.send(
            {
              type: MessageType.SYSTEM,
              tone: MessageTone.SUCCESS,
              title: 'Messages.System.File.Upload.FileVirusFalsePositiveReleasedTitle',
              content: 'Messages.System.File.Upload.FileVirusFalsePositiveReleasedContent',
              receiver_id: scanCase.uploader_id,
              game_id: scanCase.game_id || scanCase.resource?.game_id || undefined,
              meta: {
                malware_case_id: scanCase.id,
                file_name: scanCase.file_name,
                review_note: input.dto.review_note ?? null,
              },
            },
            tx,
          )
        }
      })
      if (queuedFileId) {
        await this.queueS3Upload(queuedFileId)
      }
      return
    }

    let localFilePath: string | null = null
    let sessionId: number | null = null
    let uploaderId = 0
    await this.prisma.$transaction(async tx => {
      const scanCase = await tx.malwareScanCase.findUnique({
        where: { id: input.id },
        include: {
          file: true,
          resource: {
            select: {
              id: true,
              game_id: true,
            },
          },
        },
      })
      if (!scanCase) {
        throw new ShionBizException(
          ShionBizCode.GAME_DOWNLOAD_RESOURCE_MALWARE_CASE_NOT_FOUND,
          'shion-biz.GAME_DOWNLOAD_RESOURCE_MALWARE_CASE_NOT_FOUND',
        )
      }
      if (scanCase.status !== MalwareScanCaseStatus.PENDING) {
        throw new ShionBizException(
          ShionBizCode.GAME_DOWNLOAD_RESOURCE_MALWARE_CASE_ALREADY_PROCESSED,
          'shion-biz.GAME_DOWNLOAD_RESOURCE_MALWARE_CASE_ALREADY_PROCESSED',
        )
      }

      uploaderId = scanCase.uploader_id
      const now = new Date()

      const user = await tx.user.update({
        where: { id: scanCase.uploader_id },
        data: {
          upload_injected_file_times: {
            increment: 1,
          },
        },
        select: {
          upload_injected_file_times: true,
        },
      })

      const autoBanThreshold = this.configService.get('file_scan.malware_auto_ban_threshold')
      const autoBanDurationDays = this.configService.get('file_scan.malware_auto_ban_duration_days')
      if (user.upload_injected_file_times === autoBanThreshold) {
        try {
          await this.userService.ban(
            scanCase.uploader_id,
            {
              banned_reason: `Uploaded harmful file (${autoBanThreshold} times)`,
              banned_duration_days: autoBanDurationDays,
              banned_by: input.reviewedBy,
            },
            tx,
            true,
          )
        } catch (error) {
          if (
            error instanceof ShionBizException &&
            error.code === ShionBizCode.USER_ALREADY_BANNED
          ) {
            // ignore
          } else {
            throw error
          }
        }
      }

      if (scanCase.file) {
        localFilePath = scanCase.file.file_path
        sessionId = scanCase.file.upload_session_id

        await tx.gameDownloadResourceFile.delete({
          where: { id: scanCase.file.id },
        })

        const leftFilesCount = await tx.gameDownloadResourceFile.count({
          where: {
            game_download_resource_id: scanCase.file.game_download_resource_id,
          },
        })

        if (leftFilesCount === 0) {
          await tx.gameDownloadResource.delete({
            where: { id: scanCase.file.game_download_resource_id },
          })
        }
      } else if (scanCase.resource_id) {
        const leftFilesCount = await tx.gameDownloadResourceFile.count({
          where: {
            game_download_resource_id: scanCase.resource_id,
          },
        })
        if (leftFilesCount === 0) {
          await tx.gameDownloadResource.delete({
            where: { id: scanCase.resource_id },
          })
        }
      }

      await tx.malwareScanCase.update({
        where: { id: scanCase.id },
        data: {
          status: MalwareScanCaseStatus.DELETED,
          decision_source: input.decisionSource,
          reviewed_by: input.reviewedBy,
          reviewed_at: now,
          review_note: input.dto.review_note,
          uploader_notified_at: notifyUploader ? now : null,
        },
      })

      if (notifyUploader) {
        await this.messageService.send(
          {
            type: MessageType.SYSTEM,
            tone: MessageTone.DESTRUCTIVE,
            title: 'Messages.System.File.Upload.FileVirusConfirmedDeletedTitle',
            content: 'Messages.System.File.Upload.FileVirusConfirmedDeletedContent',
            receiver_id: scanCase.uploader_id,
            game_id: scanCase.game_id || scanCase.resource?.game_id || undefined,
            meta: {
              malware_case_id: scanCase.id,
              file_name: scanCase.file_name,
              upload_injected_file_times: user.upload_injected_file_times,
              malware_auto_ban_threshold: this.configService.get(
                'file_scan.malware_auto_ban_threshold',
              ),
              review_note: input.dto.review_note ?? null,
            },
          },
          tx,
        )
      }
    })

    if (uploaderId && sessionId) {
      try {
        await this.uploadQuotaService.withdrawUploadQuotaUseAdjustment(uploaderId, sessionId)
      } catch (error) {
        const err = error as Error
        this.logger.error(
          `failed to withdraw upload quota for user ${uploaderId}, session ${sessionId}: ${err.message}`,
          err.stack,
        )
      }
    }
    await this.removeLocalFile(localFilePath)
  }

  private async notifyAdminsPendingCase(data: {
    caseId: number
    gameId: number
    fileName: string
    uploaderId: number
    reviewDeadline: Date
    detectedViruses: string[]
  }) {
    const [admins, uploader, game] = await Promise.all([
      this.getAdmins(),
      this.prisma.user.findUnique({
        where: { id: data.uploaderId },
        select: { id: true, name: true },
      }),
      this.prisma.game.findUnique({
        where: { id: data.gameId },
        select: {
          title_jp: true,
          title_zh: true,
          title_en: true,
        },
      }),
    ])
    if (admins.length === 0) return

    const siteUrl = this.configService.get('siteUrl')
    const adminReviewPath = `/admin/malware-scans?id=${data.caseId}`
    const adminReviewUrl = `${siteUrl}${adminReviewPath}`
    const uploaderName = uploader?.name ?? `User#${data.uploaderId}`
    const gameTitle = game?.title_zh || game?.title_jp || game?.title_en || '-'

    const messagePromises: Promise<unknown>[] = admins.map(admin =>
      this.messageService.send({
        type: MessageType.SYSTEM,
        tone: MessageTone.WARNING,
        title: 'Messages.System.File.Upload.FileVirusReviewRequiredTitle',
        content: 'Messages.System.File.Upload.FileVirusReviewRequiredContent',
        receiver_id: admin.id,
        game_id: data.gameId,
        link_text: 'Messages.System.File.Upload.FileVirusReviewRequiredLinkText',
        link_url: adminReviewPath,
        meta: {
          malware_case_id: data.caseId,
          file_name: data.fileName,
          uploader_name: uploaderName,
          detected_viruses: data.detectedViruses.join(', '),
          review_deadline: data.reviewDeadline.toISOString(),
        },
      }),
    )

    const adminEmails = admins.map(admin => admin.email).filter((email): email is string => !!email)
    if (adminEmails.length > 0) {
      messagePromises.push(
        this.emailService.sendMalwareScanNotification(adminEmails, {
          caseId: data.caseId,
          fileName: data.fileName,
          uploaderName,
          gameTitle,
          detectedViruses: data.detectedViruses,
          reviewDeadline: data.reviewDeadline,
          adminReviewUrl,
        }),
      )
    }

    await Promise.allSettled(messagePromises)
  }

  private async getAdmins() {
    return this.prisma.user.findMany({
      where: {
        role: {
          gte: ShionlibUserRoles.ADMIN,
        },
        status: UserStatus.ACTIVE,
      },
      select: {
        id: true,
        email: true,
      },
    })
  }

  private async queueS3Upload(fileId: number) {
    await this.uploadQueue.add(
      S3_UPLOAD_JOB,
      {
        resourceFileId: fileId,
      },
      {
        jobId: `s3-upload:${fileId.toString()}`,
        attempts: 5,
        backoff: { type: 'exponential', delay: 60_000 },
        removeOnComplete: true,
      },
    )
  }

  private extractDetectedViruses(scanResult: unknown): string[] {
    if (!scanResult || typeof scanResult !== 'object') return []
    const viruses = (scanResult as { viruses?: unknown }).viruses

    if (Array.isArray(viruses)) {
      return [...new Set(viruses.map(v => String(v).trim()).filter(Boolean))]
    }
    if (typeof viruses === 'string') {
      const trimmed = viruses.trim()
      return trimmed ? [trimmed] : []
    }
    if (viruses && typeof viruses === 'object') {
      return [
        ...new Set(
          Object.values(viruses)
            .map(v => String(v).trim())
            .filter(Boolean),
        ),
      ]
    }

    return []
  }

  private toSafeJson(data: unknown): Prisma.InputJsonValue {
    const normalized = JSON.parse(JSON.stringify(data ?? null)) as Prisma.InputJsonValue
    return normalized
  }

  private async readScanLogExcerpt(filePath: string) {
    const scanLogPath = this.configService.get('file_scan.clamscan_scan_log_path')

    try {
      const stat = await fs.stat(scanLogPath)
      const start = Math.max(0, stat.size - 256 * 1024)
      const length = stat.size - start
      if (length <= 0) return undefined

      const handle = await fs.open(scanLogPath, 'r')
      try {
        const buffer = Buffer.alloc(length)
        await handle.read(buffer, 0, length, start)
        const lines = buffer
          .toString('utf8')
          .split(/\r?\n/)
          .map(line => line.trim())
          .filter(Boolean)

        const matched = lines.filter(line => line.includes(filePath) || /FOUND/i.test(line))
        const excerpt = (matched.length ? matched : lines.slice(-20)).slice(-30).join('\n').trim()
        return excerpt || undefined
      } finally {
        await handle.close()
      }
    } catch {
      return undefined
    }
  }

  private async removeLocalFile(filePath: string | null) {
    if (!filePath) return
    const root = this.configService.get('file_upload.upload_root_dir')
    if (!filePath.startsWith(root)) {
      this.logger.warn(`skip removing unsafe file path: ${filePath}`)
      return
    }

    try {
      await fs.rm(filePath, { force: true })
    } catch (error) {
      this.logger.warn(`failed to remove local file ${filePath}: ${(error as Error).message}`)
    }
  }
}
